package jsonvalue

import (
	"container/list"
	"fmt"
	"reflect"

	"github.com/buger/jsonparser"
)

// Set type is for At() only. Please refer to At() function.
//
// This should be generated by V.Set functions ONLY.
//
// Set 类型仅用于 At() 函数，请参见 At() 函数的说明。并且该类型只能使用 V.Set 函数生成。
type Set struct {
	v *V
	c *V // child
}

// Set starts setting a child JSON value. Please refer to examples of "func (set *Set) At(...)"
//
// Set 开始设置一个 JSON 子成员。请参见 "func (set *Set) At(...)" 例子.
//
// https://godoc.org/github.com/Andrew-M-C/go.jsonvalue/#Set.At
func (v *V) Set(child *V) *Set {
	if nil == child {
		child = NewNull()
	}
	return &Set{
		v: v,
		c: child,
	}
}

// SetString is equivalent to Set(jsonvalue.NewString(s))
//
// SetString 等效于 Set(jsonvalue.NewString(s))
func (v *V) SetString(s string) *Set {
	return v.Set(NewString(s))
}

// SetBool is equivalent to Set(jsonvalue.NewBool(b))
//
// SetBool 等效于 Set(jsonvalue.NewBool(b))
func (v *V) SetBool(b bool) *Set {
	return v.Set(NewBool(b))
}

// SetInt is equivalent to Set(jsonvalue.NewInt(b))
//
// SetInt 等效于 Set(jsonvalue.NewInt(b))
func (v *V) SetInt(i int) *Set {
	return v.Set(NewInt(i))
}

// SetInt64 is equivalent to Set(jsonvalue.NewInt64(b))
//
// SetInt64 等效于 Set(jsonvalue.NewInt64(b))
func (v *V) SetInt64(i int64) *Set {
	return v.Set(NewInt64(i))
}

// SetInt32 is equivalent to Set(jsonvalue.NewInt32(b))
//
// SetInt32 等效于 Set(jsonvalue.NewInt32(b))
func (v *V) SetInt32(i int32) *Set {
	return v.Set(NewInt32(i))
}

// SetUint is equivalent to Set(jsonvalue.NewUint(b))
//
// SetUint 等效于 Set(jsonvalue.NewUint(b))
func (v *V) SetUint(u uint) *Set {
	return v.Set(NewUint(u))
}

// SetUint64 is equivalent to Set(jsonvalue.NewUint64(b))
//
// SetUint64 is equivalent to Set(jsonvalue.NewUint64(b))
func (v *V) SetUint64(u uint64) *Set {
	return v.Set(NewUint64(u))
}

// SetUint32 is equivalent to Set(jsonvalue.NewUint32(b))
//
// SetUint64 等效于 Set(jsonvalue.NewUint64(b))
func (v *V) SetUint32(u uint32) *Set {
	return v.Set(NewUint32(u))
}

// SetFloat64 is equivalent to Set(jsonvalue.NewFloat64(b))
//
// SetFloat64 等效于 Set(jsonvalue.NewFloat64(b))
func (v *V) SetFloat64(f float64, prec int) *Set {
	return v.Set(NewFloat64(f, prec))
}

// SetFloat32 is equivalent to Set(jsonvalue.NewFloat32(b))
//
// SetFloat32 等效于 Set(jsonvalue.NewFloat32(b))
func (v *V) SetFloat32(f float32, prec int) *Set {
	return v.Set(NewFloat32(f, prec))
}

// SetNull is equivalent to Set(jsonvalue.NewNull())
//
// SetNull 等效于 Set(jsonvalue.NewNull())
func (v *V) SetNull() *Set {
	return v.Set(NewNull())
}

// SetObject is equivalent to Set(jsonvalue.NewObject())
//
// SetObject 等效于 Set(jsonvalue.NewObject())
func (v *V) SetObject() *Set {
	return v.Set(NewObject())
}

// SetArray is equivalent to Set(jsonvalue.NewArray())
//
// SetArray is equivalent to Set(jsonvalue.NewArray())
func (v *V) SetArray() *Set {
	return v.Set(NewArray())
}

// At completes the following operation of Set(). It defines posttion of value in Set() and return the new value set.
//
// The usage of At() is perhaps the most important. This function will recursivly search for child value, and set the
// new value specified by Set() or SetXxx() series functions. Please unfold and read the following examples, they are important.
//
// At 完成 Set() 函数的后续操作并设置相应的子成员。其参数指定了应该在哪个位置设置子成员，并且返回被设置的子成员对象。
//
// 该函数的用法恐怕是 jsonvalue 中最重要的内容了：该函数会按照给定的可变参数递归地一层一层查找 JSON 值的子成员，并且设置到指定的位置上。
// 设置的逻辑说明起来比较抽象，请打开以下的例子以了解，这非常重要。
func (s *Set) At(firstParam interface{}, otherParams ...interface{}) (*V, error) {
	v := s.v
	c := s.c
	if nil == v || v.valueType == jsonparser.NotExist {
		return nil, ErrValueUninitialized
	}
	if nil == c || c.valueType == jsonparser.NotExist {
		return nil, ErrValueUninitialized
	}

	// this is the last iteration
	if 0 == len(otherParams) {
		switch v.valueType {
		default:
			return nil, fmt.Errorf("%v type does not supports Set()", v.valueType)

		case jsonparser.Object:
			var k string
			k, err := intfToString(firstParam)
			if err != nil {
				return nil, err
			}
			v.children.object[k] = c
			return c, nil

		case jsonparser.Array:
			pos, err := intfToInt(firstParam)
			if err != nil {
				return nil, err
			}
			err = v.setAtIndex(c, pos)
			if err != nil {
				return nil, err
			}
			return c, nil
		}
	}

	// this is not the last iterarion
	if v.valueType == jsonparser.Object {
		k, err := intfToString(firstParam)
		if err != nil {
			return nil, err
		}
		child, exist := v.children.object[k]
		if false == exist {
			if _, err := intfToString(otherParams[0]); err == nil {
				child = NewObject()
			} else if i, err := intfToInt(otherParams[0]); err == nil {
				if i != 0 {
					return nil, ErrOutOfRange
				}
				child = NewArray()
			} else {
				return nil, fmt.Errorf("unexpected type %v for Set()", reflect.TypeOf(otherParams[0]))
			}
		}
		next := Set{
			v: child,
			c: c,
		}
		_, err = next.At(otherParams[0], otherParams[1:]...)
		if err != nil {
			return nil, err
		}
		if false == exist {
			v.children.object[k] = child
		}
		return c, nil
	}

	// array type
	if v.valueType == jsonparser.Array {
		pos, err := intfToInt(firstParam)
		if err != nil {
			return nil, err
		}
		child, _ := v.childAtIndex(pos)
		isNewChild := false
		if nil == child {
			isNewChild = true
			if _, err := intfToString(otherParams[0]); err == nil {
				child = NewObject()
			} else if i, err := intfToInt(otherParams[0]); err == nil {
				if i != 0 {
					return nil, ErrOutOfRange
				}
				child = NewArray()
			} else {
				return nil, fmt.Errorf("unexpected type %v for Set()", reflect.TypeOf(otherParams[0]))
			}
		}
		next := Set{
			v: child,
			c: c,
		}
		_, err = next.At(otherParams[0], otherParams[1:]...)
		if err != nil {
			return nil, err
		}
		// OK to add this object
		if isNewChild {
			v.children.array.PushBack(child)
		}
		return c, nil
	}

	// illegal type
	return nil, fmt.Errorf("%v type does not supports Set()", v.valueType)
}

func (v *V) elementAtIndex(pos int) *list.Element {
	l := v.children.array.Len()
	if 0 == l {
		return nil
	}
	if pos < 0 {
		pos = l + pos
		if pos < 0 {
			return nil
		}
	} else if pos >= l {
		return nil
	}

	// find element at pos
	var e *list.Element
	i := 0
	for e = v.children.array.Front(); e != nil && i < pos; e = e.Next() {
		i++
	}
	return e
}

func (v *V) childAtIndex(pos int) (*V, bool) { // if nil returned, means that just push
	// find element at pos
	e := v.elementAtIndex(pos)
	if nil == e {
		return nil, true
	}
	return e.Value.(*V), false
}

func (v *V) setAtIndex(child *V, pos int) error {
	if 0 == v.children.array.Len() {
		if pos == 0 {
			v.children.array.PushBack(child)
			return nil
		}
		return ErrOutOfRange
	}

	if pos == v.children.array.Len() {
		v.children.array.PushBack(child)
		return nil
	}

	if -1 == pos {
		pos = v.children.array.Len() - 1
	}
	e := v.elementAtIndex(pos)
	if nil == e {
		return ErrOutOfRange
	}
	v.children.array.InsertBefore(child, e)
	v.children.array.Remove(e)
	return nil
}
