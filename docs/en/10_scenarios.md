<font size=6>Special Application Scenarios</font>

[Prev Page](./09_conversion.md) | [Contents](./README.md) | [Next Page](./11_comparation.md)

---

- [Sequence of Keys in JSON Object](#sequence-of-keys-in-json-object)
	- [Acquiring the original key sequence of an object](#acquiring-the-original-key-sequence-of-an-object)
	- [Serialize a JSON Object with Sequence of When Keys Are Set](#serialize-a-json-object-with-sequence-of-when-keys-are-set)
	- [Idempotent of JSON Value](#idempotent-of-json-value)
- [Special Floating Number +/-Inf and NaN](#special-floating-number--inf-and-nan)
- [Ignoring `omitempty` JSON Tag of A Struct](#ignoring-omitempty-json-tag-of-a-struct)
- [Acquiring the Original Text of the Number Typed JSON Value](#acquiring-the-original-text-of-the-number-typed-json-value)

---

As I mentioned previously in [Introduction](./01_introduction.md), various special scenarios are supported in jsonvalue.

This section describes these special applications and explains the logic and stories behind these scenarios.

---

## Sequence of Keys in JSON Object

According to the standard JSON implementation, a JSON object is a collection of key-value pairs. But in practice, I found many colleagues from different teams treat this collection of KV pairs as ordered...

So they raised issues to me:

1. When parsing a JSON text, we want to know the original sequence of keys.
2. When serializing jsonvalue, we want to specify the sequence of keys.

Using `encoding/json`, this is not supported (for `map` type). Other JSON packages? Maybe OK but difficult.

Initially, I refused to do this because I thought it was illegal. But as I found more and more people had done this strange (or stupid) work, I finally decided to implement it.

### Acquiring the original key sequence of an object

This is for the first issue. Let's take an example:

```go
const raw = `{"a":1,"b":2,"c":3}`
```

We can just deserialize it normally:

```go
v := jsonvalue.MustUnmarshalString(raw)
```

If you want to get the keys in original order, use the method `RangeObjectsBySetSequence`:

```go
keys := []string{}
v.RangeObjectsBySetSequence(func(key string, _ *V) bool {
    keys = append(keys, key)
})
fmt.Println(keys)
```

The output is `[a, b, c]` and is always guaranteed, which is the original sequence of the raw data. 

This is first supported from v1.3.1.

---

As for the second issue, there are several implementations. I will describe them in the following sections.

### Serialize a JSON Object with Sequence of When Keys Are Set

This is an option when invoking `Marshal` methods. Let me explain the title of this section:

1. If it is a jsonvalue value generated by code step by step, the KVs will be serialized in the sequence when they are set into the object.
2. If this jsonvalue value is deserialized from raw text, when marshaling, it will serialize in the original sequence of the raw JSON text.
3. With situations 1 and 2 combined, first the original sequence of the raw JSON text, then the sequence of keys set afterward.
4. If a key is first deleted and then set, or overridden afterward, use whichever is the last.

To achieve this, we may add an additional option `OptSetSequence()`, such as:

```go
const raw = `{"a":1,"b":2,"c":3}`
v := jsonvalue.MustUnmarshalString(raw) // key seq: a, b, c
v.Delete("b")                           // b is deleted, seq: a, c
v.Set(4).At("d")                        // add a new d, key seq: a, c, d
v.Set(1).At("a")                        // re-set a, use the latest one, key seq: c, d, a
s := v.MustMarshalString(OptSetSequence())
fmt.Println(s)
```

Output:

```go
{"c":3,"d":4,"a":1}
```

This feature also takes effect when parsing `struct` data (`Import()` function).

---

### Idempotent of JSON Value

There is one situation that makes the order of keys important. After generating a JSON raw text, we may calculate its checksum value. This is quite usual for some HTTP validation operations.

However, if the sequence of JSON object is unexpected, this operation is not possible. So we should ensure that the same object should always generate the same JSON text.

This issue is a bit different from the previous "set sequence".

The simplest way to achieve this is to use the additional option `OptDefaultStringSequence()`, which ensures that keys will be serialized in the order of string comparison. 

This is a simple wrapper of `strings.Compare`.

For example:

```go
// Due to the randomization of ranging over map, we cannot foresee the order of a and b.
v := jsonvalue.New(map[string]any{
    "a": 1,
    "b": 2,
    "c": 3,
})
s := v.MustMarshalString(OptDefaultStringSequence())
fmt.Println(s)
// Output:
// {"a":1,"b":2,"c":3}
```

---

## Special Floating Number +/-Inf and NaN

Using `encoding/json`, if serializing a floating number with +/- infinity or NaN, such as:

```go
func main() {
	_, err := json.Marshal(map[string]float64{
		"score": math.Inf(-1),
	})
	fmt.Println(err)
}
```

You may get an error: `json: unsupported value: -Inf`.

Perhaps you think the solution is simple: just avoid those special values.

However, as a programmer of a recommendation system, I found it quite common to get -Inf values from material scoring systems. Our original encoding protocol is protobuf, which fully supports IEEE-754. But it does not work in JSON. In many cases, we have to use JSON.

In this case, we can use jsonvalue to specify what to do with +/-Inf and NaN when marshaling. There are three types of options:

- Replace with JSON null
- Replace with another legal floating value
- Replace with JSON string

We may also take the previous example:

```go
func main() {
	v, _ := jsonvalue.Import(map[string]float64{
		"score": math.Inf(-1),
	})
	s := v.MustMarshalString(jsonvalue.OptFloatInfToFloat(23333))
	fmt.Println(s)
	// Output:
	// {"score":-23333}
}
```

Please refer to Section "[Additional Options](./12_option.md)" for the options above.

---

## Ignoring `omitempty` JSON Tag of A Struct

This option is used in `Import`. In short, when converting a `struct` to `*jsonvalue.V`, the `omitempty` tag will be ignored, resulting in the full export of the structure of the `struct`. 

Take the following struct for example:

```go
type st struct {
	A int `json:"a,omitempty"`
}

func main() {
	st := st{}
	b, _ := json.Marshal(&st)
	fmt.Println(string(b))
}
```

If no additional option is given, the output will be `{}`. But according to the issue above, it should be `{"a":0}`.

When I got this issue (in Tencent, not Github), I felt confused: if you do not want `omitempty`, then why define it?

![？？？](https://bkimg.cdn.bcebos.com/pic/8cb1cb1349540923e1860cc29958d109b2de499a?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg)

After studying this issue, I realized that the structs to be exported are generated by protobuf. All fields of structs generated by the go tool `protoc` will have `omitempty` tags added. But the issuer wanted to analyze all protobuf data, therefore the tag should be ignored.

It was a reasonable request. I even found a similar question on StackOverflow: [golang protobuf remove omitempty tag from generated json tags](https://stackoverflow.com/questions/34716238/)

It was OK to use `jsonpb` to solve this. However, it did not match some other features (for example, key sequences mentioned above). So my colleague decided to use jsonvalue and asked me for the feature.

It was not difficult to implement this. I added an additional option `OptIgnoreOmitempty()`. This is also the only supported option for the `Import` function. The code could be rewritten like: 

```go
type st struct {
	A int `json:"a,omitempty"`
}

func main() {
	st := st{}
	v, _ := jsonvalue.Import(&st, jsonvalue.OptIgnoreOmitempty())
	s := v.MustMarshalString()
	fmt.Println(s)
	// Output:
	// {"a":0}
}
```

---

## Acquiring the Original Text of the Number Typed JSON Value

Numbers are stored as binary digits in computers. But the JSON standard uses decimal numbers and does not define any conversion between binary and decimal numbers.

If we use `map[string]any` to unmarshal numbers, all numbers will be parsed to `float64` typed variables with `encoding/json`. If we accidentally set `int64` or `uint64` into JSON text, due to potential accuracy loss, some digits may be lost. 

This is a significant problem when transferring 64-bit hash numbers. If you are using `encoding/json`, you can use `json.RawMessage` to solve that. As for jsonvalue, just use `GetUint64` or `Get(...).String()`, and you can get the raw 64-bit hash number.