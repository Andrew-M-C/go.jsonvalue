
<font size=6>Special Application Scenarios</font>

[Prev Page](./09_conversion.md) | [Contents](./README.md) | [Next Page](./11_comparation.md)

---

- [Sequence of Keys in JSON Object](#sequence-of-keys-in-json-object)
	- [Acquiring the original key sequence of an object](#acquiring-the-original-key-sequence-of-an-object)
	- [Serialize a JSON Object with Sequence of When Keys Are Set](#serialize-a-json-object-with-sequence-of-when-keys-are-set)
	- [Idempotent of JSON Value](#idempotent-of-json-value)
- [Special Floating Number +/-Inf and NaN](#special-floating-number--inf-and-nan)
- [Ignoring `omitempty` JSON Tag of A Struct](#ignoring-omitempty-json-tag-of-a-struct)
- [Acquiring the Original Text of the Number Typed JSON Value](#acquiring-the-original-text-of-the-number-typed-json-value)

---

As I mentioned previously in [Introduction](./01_introduction.md), various strange scenarios are supported in jsonvalue. 

This section describes these special applications, and telling the logic and stories behind these scenarios.

---

## Sequence of Keys in JSON Object

According to standard JSON implementation, JSON object is a bunch of K-V paris. But in practical, I found many colleagues from different team treat this bunch of KV ordered...

So they raised issues to me:

1. When parsing a JSON text, we want to know the original sequence of keys.
2. When serializing jsonvalue, we want to specify the sequence of keys.

Using `encoding/json`, not supported (for `map` type). Other JSON packages? May be OK but difficult.

Initially, I refused to do this, because I thought it is illegal. But as I found more and more people had done this strange (or stupid) work, I finally decided to implement it.

### Acquiring the original key sequence of an object

This is for the first issue. Let's take one example:

```go
const raw = `{"a":1,"b":2,"c":3}`
```

We can just de-serialize it normally:

```go
v := jsonvalue.MustUnmarshalString(raw)
```

If you want to get the keys in original order, Use method `RangeObjectsBySetSequence`:

```go
keys := []string{}
v.RangeObjectsBySetSequence(func(key string, _ *V) bool {
    keys = append(keys, key)
})
fmt.Println(keys)
```

The output is `[a, b, c]` and always be guaranteed, which is the original sequence of raw data. 

It is firstly supported from v1.3.1.

---

As for second issue, there are several implementation. I will describe them in the following.

### Serialize a JSON Object with Sequence of When Keys Are Set

This is an option then invoking `Marshal` methods. Let me explain the title of this section:

1. If is a jsonvalue value generated by codes step by step, the KVs will be serialize in the sequence of then they are set into the object.
2. If this jsonvalue value is de-serialized from a raw text, when marshaling, it will serialize in the original sequence of the raw JSON text.
3. With situations 1 and 2 combined, firstly original sequence of the raw JSON text, then the sequence of set afterward.
4. If a key is firstly deleted and then set, or override afterward, use whichever the last.

To achieve this, we may add an additional option `OptSetSequence()`, such as:

```go
const raw = `{"a":1,"b":2,"c":3}`
v := jsonvalue.MustUnmarshalString(raw) // key seq: a, b, c
v.Delete("b")                           // b is deleted, seq: a, v
v.Set(4).At("d")                        // add a new d,key seq: a, c, d
v.Set(1).At("a")                        // re-set a, use the latest one, key seq: c, d, a
s := v.MustMarshalString(OptSetSequence())
fmt.Println(s)
```

Output:

```go
{"c":3,"d":4,"a":1}
```

This feature also takes effect in parsing a `struct` data (`Import()` function).

---

### Idempotent of JSON Value

There is one situation make the order of keys important. After generating a JSON raw text, we may calculate its checksum value. This is quite usual for some HTTP validate operation.

However, if the sequence of JSON object is un-expected, this operation is not possible. So we should be sure that the same object should always generate the same JSON text.

This issue is a bit different from the previous "set sequence".

The simplest way to achieve this is tu use additional option `OptDefaultStringSequence()`. Which ensure that keys will be serialized in sequence of string compare order. 

This is the simple package of `strings.Compare`.

For example:

```go
// As the randomizing of ranging map, we cannot foresee the order of a and b.
v := jsonvalue.New(map[string]any{
    "a": 1,
    "b": 2,
    "c": 3,
})
s := v.MustMarshalString(OptDefaultStringSequence())
fmt.Println(s)
// Output:
// {"a":1,"b":2,"c":3}
```

---

## Special Floating Number +/-Inf and NaN

Using `encoding/json`, If serializing a floating number with +/- infinity or NaN, such as:

```go
func main() {
	_, err := json.Marshal(map[string]float64{
		"score": math.Inf(-1),
	})
	fmt.Println(err)
}
```

You may get an error: `json: unsupported value: -Inf`.

Perhaps you think the solution is simple: just avoiding those special values.

However, as a programmer of recommend system, I found it quite common to getting -Inf value from material scoring system. Our original encoding protocol is protobuf, fully-supporting IEEE-754. But it does not work in JSON. In many case, we have to use JSON.

In this case, we can use jsonvalue to specify what to do with +/-Inf and NaN when marshaling. There are three types or options:

- Replace with JSON null
- Replace with another legal floating value
- Replace with JSON string

We may also take the previous example:

```go
func main() {
	v, _ := jsonvalue.Import(map[string]float64{
		"score": math.Inf(-1),
	})
	s := v.MustMarshalString(jsonvalue.OptFloatInfToFloat(23333))
	fmt.Println(s)
	// Output:
	// {"score":-23333}
}
```

Please refer to Section "[Additional Options](./12_option.md)" for options above。

---

## Ignoring `omitempty` JSON Tag of A Struct

This options is used in `Import`. In short, when converting a `struct` to `*jsonvalue.V`, the `omitempty` tag will be ignored, resulting the fully exporting to the structure of the `struct`. 

Take the following struct for example:

```go
type st struct {
	A int `json:"a,omitempty"`
}

func main() {
	st := st{}
	b, _ := json.Marshal(&st)
	fmt.Println(string(b))
}
```

If no additional option is given, the output will be `{}`. But according the issue above, it should be `{"a":0}`

When I got this issue (in Tencent, not Github), I felt confused: if you do not want `omitempty`, then why define it?

![？？？](https://bkimg.cdn.bcebos.com/pic/8cb1cb1349540923e1860cc29958d109b2de499a?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg)

After studying this issue, I realized that the structs to be exported are generated by protobuf. all fields of structs generated by go tool `protoc`, will be added `omitempty` tags. But the issuer wanted to analyze all protobuf data, therefore the tag should be ignored.

It was a reasonable request. I even found a similar question in StackOverflow: [golang protobuf remove omitempty tag from generated json tags](https://stackoverflow.com/questions/34716238/)

It was OK to use `jsonpb` to solve this. However it did not match some other features (for example, key sequences mentioned above). So my colleague decided to use jsonvalue and ask me for the feature.

It was not difficult to implement this. I added an additional option `OptIgnoreOmitempty()`. While it is also the only supported option for `Import` function. The codes could be re-written like: 

```go
type st struct {
	A int `json:"a,omitempty"`
}

func main() {
	st := st{}
	v, _ := jsonvalue.Import(&st, jsonvalue.OptIgnoreOmitempty())
	s := v.MustMarshalString()
	fmt.Println(s)
	// Output:
	// {"a":0}
}
```

---

## Acquiring the Original Text of the Number Typed JSON Value

Numbers are stored as binary digits in computers. But JSON standard use decimal number, and not defined any conversion between binary and decimal numbers.

If we use `map[string]any` to unmarshal numbers, all numbers will be parsed to `float64` typed variable with `encoding/json`. If we accidentally set `int64` or `uint64` into JSON text, due to potential accuracy loss, some digit may loss. 

It is a significant problem when transferring 64-bit hash numbers. If you are using `encoding/json`, you can use `json.RawMessage` to solve that. As for jsonvalue, just use `GetUint64` or `Get(...).String()`, you can get the raw 64-bit hash number.
